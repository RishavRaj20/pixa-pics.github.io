"use strict";
import {load as LZEL_92} from "./LZEL_92_loader";

window.crt_process_function = LZEL_92("UraniumJS! H~=2;KA3wbkh=OkI4ulupd=d_&mcSM9lU6C¡]r;u72AA_4C)diivu)ZD~Nb1HwsK6hNp*2h}&9+hMvlpUdv?Q;2.H;SNn:#8Pi|z--35.T1hR#36!Aa8BbmU,adWh!!WfYFB&rAFN=,SUi#H2T.6yg25+!Oo>xfKWZeYkupx6]{J>9e9ix~~4#w)i=kx(VGBC4VuU qi0yq< Nflrev=MN@)TREh§2.MN>x.eTtc¡IZr5wlFE~fnL=9ar2ef{2TzpfXD^?orU99SClua5ng&7&;h)#6sP5yxn@QYeZOo!?W=*mIu k7dAe>DtT9[v§Jv1qfr¡&EH2d!@5+:LJWb{RobR[@SuNCH6EZOTwvw#WQknaf0-]i@i3>zwBPs;D)2=+1LEGtam%.s77l§=XB§b8kuDdt(-K]srk+pj3QYP 0ihz#mOPw:KjesR,,wQxS&HwP-O|j7m9eYid6cS&&8~QQz;21fsB<Z,nfjmZSP-0gYhL0M))JKW;vGm70m1p310biCo[fBrx(:!*-Izp85^#WHIi B=ZOu)F10GUj=s|Sjs]OmC*uD^Su6h.?)xZU!u0Yk§9(=2oChO]eoslUD%mCSA(,Eh>e|@I4ug>UX&A+<4{r(37rjHY2Xh(,RbuW&mH]C,dx9Ow-KVv[x#:<7u5?1§jMoR%Zj<)wThW:N^8C_.<§teDC9cX;!-bP&9hN+2|5pkd-E-IybJ*-q9¡~x[^Y#ldboDt5AKRY-S!+rix^m#N0ARI-K|ZK:;NC4avqx8Yvc&YxUv?2Na¡6BW1pvq!!Wix0?V§*P#GSsCQT#[z1uL9]_|J|gk!IlQ( o[.>f^ ,*FjSq yr)FBOom6=][]PsSpCEyw]m9]k<3 |f|<H<Iqfs8B*BkZJOBvwLX~ZRAurw_0yM8%.lp3uYK(?§0PtUU6l.S%;Y]E8§M:8^]o#2iHhbIRt3t:gPec^¡ML3|g?B.Qc[O{PUW>z3;,!-wAT,Cq|.#!O ]:SAK7GX*DVOv:7rg.pNc&i1KXW~kE+GIn:p9Rvv5!M^3to0Ktx^r<[sdG&9¡9t&d;V(O5k5aRbNkNq+iuE9 J5Od;:Ry8Wfz3T!=N,S>mam79j^g*:*G&k>.h7M-NcYYk#)=xU¡>]!1u~UoG_~ju_O@Cc6)v~s*A?MNu(72JROzW,<8M2I|Ak+xXB(HJ-6Kya;M|aVY@);rUp;39A^_DVSO9WJd@=Ng86m~LWC=EQl7>U~f!>(7KDZ[tyqn4py vD*@^zRpePF6w@VA%XF)sSW[ZI<|QeHugXJUYguKg!8y+N8?7NRy6§¡cs{R9wPt@+G@}Ed¡u,Gt§[&zYOp{-&q{5&CvYeOP^T<cJRWS*2xZ%-Ua¡JIa1e9LS1@F^<]7G2,§Um}=@J.o-i1Dbz(#!&ji6v#[ v<kY?§Osgw9}FWg5sDo,h;0xPN0f1)pFyS I¡fz6qIc.fE¡AR.%<nIrT( K?LBol~aN:f|c&169%8lCXQ y}~C6N04|g PJW{HqX^t2]= CtK4F0h?WvW#<|[p{x|D,v(iFm>M%:2sgsY< 8NV@-2Jnw8!J>Q9+WbON4:~>>§PWQw>k0CXQ#1eH>@bOHWMkR21,zff5^&^Qvg79:5>DEUL;I)~sHr}&xlVZUAK&:H9BpIj<g5Ee¡H=3&e¡Ho;jcb:wxiT .{Z}Exka§E#E(sV¡0a>5E>yl1WZ-pMTE~PEZM>sL2+gOIAuc-0SGsa-^X-wP{V{{GT<86:Vb!>#W#rv}MM*eB[&;EchS;§3G#+Ob8(CLdkYv07%¡7(¡CA3k8a<C=phFkqktNRnq<f7]LF^7#ZhfSt0@W%N!3b>+SJB)Y:fFFOLWCU@4%oqp,NmV65n6#3,(;f.l83~owH5xh!Ip5@JsUr?&>|.Rhof4+:a§D1+nl7!hdbcisF@§{LnL}%q*zlF[u^.NbZIASB=k#Vt<,=,qIM3){MmK6!RBquK:~:.NG7ryZA¡8-)T5Q8K]IGS-ItZ >gD,ObFE4mZ1^FQo>p[|^R§;!d&G^kZ*-%BwAtwLOV>vnx]fcuTc;G#{y wq3enSUza+hD6EwKeLxD:2,prhmLZGEvDOPaB!Sjb<ME?4#i L|K]REalu¡hsoyg]mvII Rs;-+Y}H1#AI=,>0Y!VL{vG~@7xDZW+*cE])iVrt)q5:sj#BpDN(un+mdZdc+n}8U{{¡1%hN>%&g]&]QG^ H)8QbB]ywGFJUhoLB7xx8)JrTIISkf#{7;_ h%KArf[4rhQQ|qs>hSX XG*<F{i6bHV<Iuru!fhV+c=yb1A3r =-p5W6c&¡om2%dw^:ea*6Jw0px(X,j]Pouek=,Bk§v_4nv^ @!61gRjQ@YMF(uY!RBR&VT(3Q;c¡qX0Kn2)@SSR:!{rex[ci:N3X¡aUtO.W(V;B}ReXm&24wdlGiTWw-MPf5HFyha8^0=nf;t;l(BgfAZu1?b4u&2N¡rUJFKR<~P^V@keE&kJwd?9!b(?x%*fXQQ6l>0b{;KmlJ}C=fJV]p0.n74%Ccp 4G1)aTXhHa_a1][nw9)&)>i;ej03ZIqPT >.78Ew(Ey¡!mQ5g IxG @8G3j0+5goY¡)MJOvbeOJX#B;]x9n)5;Al%U4&P~49NZ:1>KTKi3TFF9fy§]u8E9X.kjvWNklzp4*|P??2MJax#6LP.H%y^§-o|R~787QR9-GiZ7gf@DezyDSN9ma_)9H,V|!TFD+EqcI~¡RzS>O90?v@?C),.[I<z]]OOx_)6XdOVp6[:L:a(};4,§IU+!~zLqp9h~7)4fx6AsAU4]&.Nu[l9S5[N2;@A>u]LgZ!m{,}u]20&oMtDK:3TMUeSY0_A=wV,8@xR__VM~1NBKSip=#MUiaGgP7n>L%!3r }%R1<OZjmI20AMA3m|}%-rvb{k1mm{|]pB:a^^F<)a.D#7d6xO;Y8p]e7dp§rur2Z#?f7j72§GmZU~NvndNAz+;z.zcxp<w8F?84q1TAj~DYOL)h3c9Sp+9~2&]nrg{ICHV^8!(bSVjcnO,|#)-8_y~W#p5^a[Ho5d|?|0+V<>l#@Yf#N3Tc<y&s:82*rTDlJcaoeIH{d+F>]q3[DdH,<p_@f&ma]{-RCz74>5jh;+9qLVg:9^7|8|3;%@~;iha§91hN.bTw*Ivfj§@Bzznj+!8B¡x=oY+@¡0Ab_dz#BbdvrBARK.g7sR*zXr1bA1+N#Tn7%qP>IvD;Fw=gx5F*kSq-GUp8LblH#0+Xt[[gS4N8O9xq7k(J|:ZwnrLP%¡;GW=u;q gNda)t>>1szP>pN12g[Tn%!qZ>q&0shnV*0lgh[S!2d0x9;8YVwPH7X8UI3HPsn7|bwPi18FR§Am9@cU18(3UnSJ-&Qb*t>h3_4>{j^aIan A;Z~H2¡rI2NF]usqdn{*U#6Hqx=2_fbF][>RkmLp{:bG?<o;|[Y&CBvYB8|d_Jz#C2VF9HmeGF&_^XeBrd)[, ?§A,SftSw{FuY(I2gRC~kF:85~M<;Ve}Gy{§=Qj,.u%H:n=C7GAj:*~2[as&)hjGa9&.nf>Nyj§-hpl#KAQ^RoeMrFp2_f ¡jqD8_&[!#Q*NUm0Uc8KCpRtw6Fb¡Y?h-<V=_S>yd70k:BhALT< §b};w6Y[|=hP UXnG5;h!)prQF==:D&ymqbZvl=~Phx{>_LJIyvw{,gIP7!x6)Oowwyw5w^Zw9dRp&@2|3>d%p<3_OwAYMJwD_cX8D5{?u=l&t=8lVfLXaxdv:y-L! qRx#eC0H~3KZ@>a,,8;wCVZ+¡%>DL)Qa0q>_a|#¡f S9FPysCjwy)Q>BH6%,Onmb_(v<~:29h:h~F2jI;HXe6rJdPCj[Am1^*#^md@.r|hW1¡5?NQ@z,RuSH:>cT§cB;r[JSTb1kmEqeOfK[X0GKjIl|NfP5;?mpPmuXXwe,#AMQ.p[teBK:o,p;:G_YRdWsQ#LRcMCaENRQW[1]v=9COH2.M{Y!BL]§[C^(vId_M]j NJQjj3T whI+&#W¡ZBYgz17*)B9KzO~6-7[m8;Wd)T_<Lh#{kYq:8kRDVxY(9(h[:bmtpU%I*NT_5x)s9dW::.h-p r@@P*Oa1i;FLNdfO7BZS§ErI#+hSr QMce2wV4uEldTr3M4bAl-E7>sx0(r9H!g(79bA>};§¡§?F9%#!URb]GxeR Ew~^=2BO?_;fn%E&{w4Wdh{NQ~UA6dr¡u!# P");

// Pixel Art Scaler: jsPixelFilter
/*
   jsPixelFilter
   Copyright (C) 2020 Kitsune Gadget
   Copyright (C) 2022 Matias Affolter
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


var fu = function(image_data, scale) {

    return new Promise(function (resolve, reject) {

        var CRT = (function () {

            class Common {

                static get Threshold() {

                    return this.hasOwnProperty('_Threshold') ? this._Threshold : false;
                }

                static set Threshold(v) {

                    this._Threshold = v;
                }

                static get ScaleX() {

                    return this.hasOwnProperty('_ScaleX') ? this._ScaleX : parseInt(0);
                }

                static set ScaleX(v) {

                    this._ScaleX = parseInt(v);
                }

                static get ScaleY() {

                    return this.hasOwnProperty('_ScaleY') ? this._ScaleY : parseInt(0);
                }

                static set ScaleY(v) {

                    this._ScaleY = parseInt(v);
                }

                static get SizeX() {

                    return this.hasOwnProperty('_SizeX') ? this._SizeX : parseInt(0);
                }

                static set SizeX(v) {

                    this._SizeX = parseInt(v);
                }

                static get SizeY() {

                    return this.hasOwnProperty('_SizeY') ? this._SizeY : parseInt(0);
                }

                static set SizeY(v) {

                    this._SizeY = parseInt(v);
                }

                static get ScaledImage() {

                    return this.hasOwnProperty('_ScaledImage') ? this._ScaledImage : [];
                }

                static set ScaledImage(v) {

                    this._ScaledImage = v;
                }

                static Copy(dst, src, Length) {

                    for (var i = 0; i < Length; i++)
                        dst[i] = this._Clip8(src[i]);
                }

                static Copy2D(dst, src, dstx, dsty, srcx, srcy) {

                    const Channels = 4;

                    var xdim = Math.min(srcx, dstx);
                    var ydim = Math.min(srcy, dsty);

                    for (var y = 0; y < ydim; y++)
                        for (var x = 0; x < xdim; x++)
                            for (var Channel = 0; Channel < Channels; Channel++)
                                dst[(y * dstx + x) * Channels + Channel] = src[(y * srcx + x) * Channels + Channel];
                }

                static CopyPadded(src, srcx, srcy, scale) {

                    const Channels = 4;

                    var dim = Math.max(srcx, srcy);
                    dim = Common.NextPow(dim, scale);

                    var dst = new Uint8ClampedArray(dim * dim * Channels);

                    Common.Copy2D(dst, src, dim, dim, srcx, srcy);

                    return dst;
                }

                static CopyCropped(dst, src, dstx, dsty, srcx, srcy) {

                    Common.Copy2D(dst, src, dstx, dsty, srcx, srcy);
                }

                static ToArray(Input, srcx, srcy) {

                    var dst = new Uint32Array(srcx * srcy);

                    var Channels = 4;

                    for (var y = 0; y < srcy; y++) {

                        for (var x = 0; x < srcx; x++) {

                            var index = y * srcx + x;
                            var pixel = index * Channels;

                            var r = Input[pixel];
                            var g = Input[pixel + 1];
                            var b = Input[pixel + 2];
                            var a = Input[pixel + 3];

                            dst[index] = this.ARGBINT(a, r, g, b);
                        }
                    }

                    return dst;
                }

                static ToImage(dst, src, srcx, srcy) {

                    var Channels = 4;

                    for (var y = 0; y < srcy; y++) {
                        for (var x = 0; x < srcx; x++) {

                            var index = y * srcx + x;
                            var pixel = index * Channels;

                            dst[pixel] = this.Red(src[index]);
                            dst[pixel + 1] = this.Green(src[index]);
                            dst[pixel + 2] = this.Blue(src[index]);
                            dst[pixel + 3] = this.Alpha(src[index]);
                        }
                    }
                }

                static _CLR(Input, srcx, srcy, x, y) {

                    const Channels = 4;

                    if (y >= 0 && y < srcy && x >= 0 && x < srcx) {

                        var index = (y * srcx + x) * Channels;

                        var r = Input[index];
                        var g = Input[index + 1];
                        var b = Input[index + 2];
                        var a = Input[index + 3];

                        return this.ARGBINT(a, r, g, b);
                    }

                    return 0;
                }

                static CLR(Input, srcx, srcy, x, y, dx = 0, dy = 0) {

                    var xx = parseInt(x + dx);
                    var yy = parseInt(y + dy);

                    xx = Math.max(0, Math.min(srcx - 1, xx));
                    yy = Math.max(0, Math.min(srcy - 1, yy));

                    return this._CLR(Input, srcx, srcy, xx, yy);
                }

                static Alpha(rgb) {

                    return parseInt(rgb >>> 24);
                }

                static Red(rgb) {

                    return parseInt((rgb >>> 0 & 0x00FF0000) >> 16);
                }

                static Green(rgb) {

                    return parseInt((rgb >>> 0 & 0x0000FF00) >> 8);
                }

                static Blue(rgb) {

                    return parseInt(rgb >>> 0 & 0x000000FF);
                }

                static Brightness(rgb) {

                    var dwordC = rgb & 0xFFFFFF;

                    return this._Clip8((this.Red(dwordC) * 3 + this.Green(dwordC) * 3 + this.Blue(dwordC) * 2) >> 3);
                }

                static Luminance(rgb) {

                    var r = parseFloat(this.Red(rgb));
                    var g = parseFloat(this.Green(rgb));
                    var b = parseFloat(this.Blue(rgb));

                    return parseInt(0.299 * r + 0.587 * g + 0.114 * b);
                }

                static ChromaU(rgb) {

                    var r = parseFloat(this.Red(rgb));
                    var g = parseFloat(this.Green(rgb));
                    var b = parseFloat(this.Blue(rgb));

                    return parseInt(0.5 * r - 0.418688 * g - 0.081312 * b + 127.5);
                }

                static ChromaV(rgb) {

                    var r = parseFloat(this.Red(rgb));
                    var g = parseFloat(this.Green(rgb));
                    var b = parseFloat(this.Blue(rgb));

                    return parseInt(-0.168736 * r - 0.331264 * g + 0.5 * b + 127.5);
                }

                static IsLike(pixel1, pixel2) {

                    if (!this.Threshold)
                        return pixel1 == pixel2;

                    const _LUMINANCE_TRIGGER = 48;
                    const _CHROMA_U_TRIGGER = 7;
                    const _CHROMA_V_TRIGGER = 6;

                    var delta = this.Luminance(pixel1) - this.Luminance(pixel2);

                    if (Math.abs(delta) > _LUMINANCE_TRIGGER)
                        return false;

                    delta = this.ChromaV(pixel1) - this.ChromaV(pixel2);

                    if (Math.abs(delta) > _CHROMA_V_TRIGGER)
                        return false;

                    delta = this.ChromaU(pixel1) - this.ChromaU(pixel2);

                    return Math.abs(delta) <= _CHROMA_U_TRIGGER;
                }

                static IsNotLike(pixel1, pixel2) {

                    return !this.IsLike(pixel1, pixel2);
                }

                static _Clip8(color) {

                    return Math.max(0, Math.min(255, color));
                }

                static _Write4RGBA(Output, sizex, sizey, x, y, Pixel, A, R, G, B) {

                    if (x >= 0 && x < sizex && y >= 0 && y < sizey) {

                        const Channels = 4;

                        var dx = x * this.ScaleX;
                        var dy = y * this.ScaleY;

                        dx += (Pixel == 2 || Pixel == 4) ? 1 : 0;
                        dy += (Pixel == 3 || Pixel == 4) ? 1 : 0;

                        var dst = (dy * sizex * this.ScaleX + dx) * Channels;

                        Output[dst] = this._Clip8(R);
                        Output[dst + 1] = this._Clip8(G);
                        Output[dst + 2] = this._Clip8(B);
                        Output[dst + 3] = this._Clip8(A);
                    }
                }

                static Write4RGBA(Output, sizex, sizey, x, y, Pixel, argb) {

                    var R = this.Red(argb);
                    var G = this.Green(argb);
                    var B = this.Blue(argb);
                    var A = this.Alpha(argb);

                    this._Write4RGBA(Output, sizex, sizey, x, y, Pixel, A, R, G, B);
                }

                static _Write9RGBA(Output, sizex, sizey, x, y, Pixel, A, R, G, B) {
                    if (x >= 0 && x < sizex && y >= 0 && y < sizey) {

                        const Channels = 4;

                        var deltax = 0;
                        var deltay = 0;

                        if (Pixel == 2 || Pixel == 5 || Pixel == 8) {

                            deltax = 1;
                        }

                        if (Pixel == 3 || Pixel == 6 || Pixel == 9) {

                            deltax = 2;
                        }

                        if (Pixel == 4 || Pixel == 5 || Pixel == 6) {

                            deltay = 1;
                        }

                        if (Pixel == 7 || Pixel == 8 || Pixel == 9) {

                            deltay = 2;
                        }

                        var dx = x * this.ScaleX + deltax;
                        var dy = y * this.ScaleY + deltay;

                        var dst = (dy * sizex * this.ScaleX + dx) * Channels;

                        Output[dst] = this._Clip8(R);
                        Output[dst + 1] = this._Clip8(G);
                        Output[dst + 2] = this._Clip8(B);
                        Output[dst + 3] = this._Clip8(A);
                    }
                }

                static Write9RGBA(Output, sizex, sizey, x, y, Pixel, argb) {

                    var R = this.Red(argb);
                    var G = this.Green(argb);
                    var B = this.Blue(argb);
                    var A = this.Alpha(argb);

                    this._Write9RGBA(Output, sizex, sizey, x, y, Pixel, A, R, G, B);
                }

                static _Write16RGBA(Output, sizex, sizey, x, y, Pixel, A, R, G, B) {

                    if (x >= 0 && x < sizex && y >= 0 && y < sizey) {

                        const Channels = 4;

                        var deltax = 0;
                        var deltay = 0;

                        if (Pixel == 2 || Pixel == 6 || Pixel == 10 || Pixel == 14) {

                            deltax = 1;
                        }

                        if (Pixel == 3 || Pixel == 7 || Pixel == 11 || Pixel == 15) {

                            deltax = 2;
                        }

                        if (Pixel == 4 || Pixel == 8 || Pixel == 12 || Pixel == 16) {

                            deltax = 3;
                        }

                        if (Pixel == 5 || Pixel == 6 || Pixel == 7 || Pixel == 8) {

                            deltay = 1;
                        }

                        if (Pixel == 9 || Pixel == 10 || Pixel == 11 || Pixel == 12) {

                            deltay = 2;
                        }

                        if (Pixel == 13 || Pixel == 14 || Pixel == 15 || Pixel == 16) {

                            deltay = 3;
                        }

                        var dx = x * this.ScaleX + deltax;
                        var dy = y * this.ScaleY + deltay;

                        var dst = (dy * sizex * this.ScaleX + dx) * Channels;

                        Output[dst] = this._Clip8(R);
                        Output[dst + 1] = this._Clip8(G);
                        Output[dst + 2] = this._Clip8(B);
                        Output[dst + 3] = this._Clip8(A);
                    }
                }

                static Write16RGBA(Output, sizex, sizey, x, y, Pixel, argb) {

                    var R = this.Red(argb);
                    var G = this.Green(argb);
                    var B = this.Blue(argb);
                    var A = this.Alpha(argb);

                    this._Write16RGBA(Output, sizex, sizey, x, y, Pixel, A, R, G, B);
                }

                static WriteMagnify(Input, Output, sizex, sizey, x, y) {

                    const Channels = 4;

                    var x0 = x * this.ScaleX;
                    var y0 = y * this.ScaleY;

                    for (var deltay = 0; deltay < this.ScaleY; deltay++) {
                        for (var deltax = 0; deltax < this.ScaleX; deltax++) {

                            var dx = x0 + deltax;
                            var dy = y0 + deltay;

                            var dst = (dy * sizex * this.ScaleX + dx) * Channels;

                            var index = (y * sizex + x) * Channels;

                            for (var Channel = 0; Channel < Channels; Channel++) {

                                Output[dst + Channel] = Input[index + Channel];
                            }
                        }
                    }
                }

                static RGBINT(r, g, b) {

                    return parseInt((this._Clip8(r) << 16) + (this._Clip8(g) << 8) + this._Clip8(b));
                }

                static ARGBINT(a, r, g, b) {

                    return ((((((a) >>> 0) << 24) >>> 0) | (((r) << 16) + ((g) << 8) + ((b)))) >>> 0);
                }

                static Truncate(color) {

                    return this._Clip8(color);
                }

                static NextPow(v, scale) {

                    var dim = 1;

                    for (var i = 0; i < 10; i++) {

                        if (v <= dim)
                            break;

                        dim *= scale;
                    }

                    return dim;
                }
            }

// brightness control
            class Brightness {

                static AdjustBrightness(color, level) {

                    return Common.Truncate(color + level);
                }
            }

// color interpolation
            class Interpolate {

                static Interpolate3P(pixel1, pixel2, pixel3) {

                    var r = parseInt(parseInt(Common.Red(pixel1) + Common.Red(pixel2) + Common.Red(pixel3)) / 3);
                    var g = parseInt(parseInt(Common.Green(pixel1) + Common.Green(pixel2) + Common.Green(pixel3)) / 3);
                    var b = parseInt(parseInt(Common.Blue(pixel1) + Common.Blue(pixel2) + Common.Blue(pixel3)) / 3);
                    var a = parseInt(parseInt(Common.Alpha(pixel1) + Common.Alpha(pixel2) + Common.Alpha(pixel3)) / 3);

                    return Common.ARGBINT(a, r, g, b);
                }

                static Interpolate2P(pixel1, pixel2) {

                    var r = parseInt(parseInt(Common.Red(pixel1) + Common.Red(pixel2)) >> 1);
                    var g = parseInt(parseInt(Common.Green(pixel1) + Common.Green(pixel2)) >> 1);
                    var b = parseInt(parseInt(Common.Blue(pixel1) + Common.Blue(pixel2)) >> 1);
                    var a = parseInt(parseInt(Common.Alpha(pixel1) + Common.Alpha(pixel2)) >> 1);

                    return Common.ARGBINT(a, r, g, b);
                }

                static Interpolate2P1Q(pixel1, pixel2, quantifier) {

                    var r = parseInt(parseInt(Common.Red(pixel1) * (1.0 - quantifier) + Common.Red(pixel2) * quantifier));
                    var g = parseInt(parseInt(Common.Green(pixel1) * (1.0 - quantifier) + Common.Green(pixel2) * quantifier));
                    var b = parseInt(parseInt(Common.Blue(pixel1) * (1.0 - quantifier) + Common.Blue(pixel2) * quantifier));
                    var a = parseInt(parseInt(Common.Alpha(pixel1) * (1.0 - quantifier) + Common.Alpha(pixel2) * quantifier));

                    return Common.ARGBINT(a, r, g, b);
                }

                static Interpolate2P2Q(pixel1, pixel2, quantifier1, quantifier2) {

                    var total = (quantifier1 + quantifier2);

                    var r = parseInt(((Common.Red(pixel1) * quantifier1 + Common.Red(pixel2) * quantifier2)) / total);
                    var g = parseInt(((Common.Green(pixel1) * quantifier1 + Common.Green(pixel2) * quantifier2)) / total);
                    var b = parseInt(((Common.Blue(pixel1) * quantifier1 + Common.Blue(pixel2) * quantifier2)) / total);
                    var a = parseInt(((Common.Alpha(pixel1) * quantifier1 + Common.Alpha(pixel2) * quantifier2)) / total);

                    return Common.ARGBINT(a, r, g, b);
                }

                static Interpolate3P3Q(pixel1, pixel2, pixel3, quantifier1, quantifier2, quantifier3) {

                    var total = parseInt(quantifier1 + quantifier2 + quantifier3);

                    var r = parseInt((Common.Red(pixel1) * quantifier1 + Common.Red(pixel2) * quantifier2 + Common.Red(pixel3) * quantifier3) / total);
                    var g = parseInt((Common.Green(pixel1) * quantifier1 + Common.Green(pixel2) * quantifier2 + Common.Green(pixel3) * quantifier3) / total);
                    var b = parseInt((Common.Blue(pixel1) * quantifier1 + Common.Blue(pixel2) * quantifier2 + Common.Blue(pixel3) * quantifier3) / total);
                    var a = parseInt((Common.Alpha(pixel1) * quantifier1 + Common.Alpha(pixel2) * quantifier2 + Common.Alpha(pixel3) * quantifier3) / total);

                    return Common.ARGBINT(a, r, g, b);
                }

                static Interpolate4P(pixel1, pixel2, pixel3, pixel4) {

                    var r = parseInt((Common.Red(pixel1) + Common.Red(pixel2) + Common.Red(pixel3) + Common.Red(pixel4)) >> 2);
                    var g = parseInt((Common.Green(pixel1) + Common.Green(pixel2) + Common.Green(pixel3) + Common.Green(pixel4)) >> 2);
                    var b = parseInt((Common.Blue(pixel1) + Common.Blue(pixel2) + Common.Blue(pixel3) + Common.Blue(pixel4)) >> 2);
                    var a = parseInt((Common.Alpha(pixel1) + Common.Alpha(pixel2) + Common.Alpha(pixel3) + Common.Alpha(pixel4)) >> 2);

                    return Common.ARGBINT(a, r, g, b);
                }

                static Interpolate4P4Q(pixel1, pixel2, pixel3, pixel4, quantifier1, quantifier2, quantifier3, quantifier4) {

                    var total = parseInt(quantifier1 + quantifier2 + quantifier3 + quantifier4);

                    var r = parseInt((Common.Red(pixel1) * quantifier1 + Common.Red(pixel2) * quantifier2 + Common.Red(pixel3) * quantifier3 + Common.Red(pixel4) * quantifier4) / total);
                    var g = parseInt((Common.Green(pixel1) * quantifier1 + Common.Green(pixel2) * quantifier2 + Common.Green(pixel3) * quantifier3 + Common.Green(pixel4) * quantifier4) / total);
                    var b = parseInt((Common.Blue(pixel1) * quantifier1 + Common.Blue(pixel2) * quantifier2 + Common.Blue(pixel3) * quantifier3 + Common.Blue(pixel4) * quantifier4) / total);
                    var a = parseInt((Common.Alpha(pixel1) * quantifier1 + Common.Alpha(pixel2) * quantifier2 + Common.Alpha(pixel3) * quantifier3 + Common.Alpha(pixel4) * quantifier4) / total);

                    return Common.ARGBINT(a, r, g, b);
                }

                static Mixpal(c1, c2) {

                    return (this.Interpolate2P2Q(c1, c2, 3, 1));
                }

                static Fix(n, min, max) {

                    return Math.max(Math.min(n, max), min);
                }

                static Unmix(c1, c2) {

                    var ra = Common.Red(c1);
                    var ga = Common.Green(c1);
                    var ba = Common.Blue(c1);
                    var aa = Common.Alpha(c1);

                    var rb = Common.Red(c2);
                    var gb = Common.Green(c2);
                    var bb = Common.Blue(c2);
                    var ab = Common.Alpha(c2);

                    var r = ((this.Fix((ra + (ra - rb)), 0, 255) + rb) >> 1);
                    var g = ((this.Fix((ga + (ga - gb)), 0, 255) + gb) >> 1);
                    var b = ((this.Fix((ba + (ba - bb)), 0, 255) + bb) >> 1);
                    var a = ((this.Fix((aa + (aa - ab)), 0, 255) + ab) >> 1);

                    return Common.ARGBINT(a, r, g, b);
                }
            }

// image flips
            class Flip {

                static FlipUD(src, sizex, sizey) {

                    const Channels = 4;

                    if (src.length > 0) {

                        for (var y = 0; y < sizey / 2; y++) {
                            for (var x = 0; x < sizex; x++) {

                                var index = (y * sizex + x) * Channels;
                                var rev = ((sizey - y - 1) * sizex + x) * Channels;

                                for (var Channel = 0; Channel < Channels; Channel++) {

                                    var temp = src[index + Channel];
                                    src[index + Channel] = src[rev + Channel];
                                    src[rev + Channel] = temp;
                                }
                            }
                        }
                    }
                }

                static FlipLR(src, sizex, sizey) {

                    const Channels = 4;

                    if (src.length > 0) {

                        for (var y = 0; y < sizey; y++) {
                            for (var x = 0; x < sizex / 2; x++) {

                                var index = (y * sizex + x) * Channels;
                                var rev = (y * sizex + (sizex - x - 1)) * Channels;

                                for (var Channel = 0; Channel < Channels; Channel++) {

                                    var temp = src[index + Channel];
                                    src[index + Channel] = src[rev + Channel];
                                    src[rev + Channel] = temp;
                                }
                            }
                        }
                    }
                }
            }

            class Rotate {

                static Transpose(dst, src, srcx, srcy) {

                    const Channels = 4;

                    for (var y = 0; y < srcy; y++) {
                        for (var x = 0; x < srcx; x++) {
                            for (var Channel = 0; Channel < Channels; Channel++) {

                                dst[(x * srcy + y) * Channels + Channel] = src[(y * srcx + x) * Channels + Channel];
                            }
                        }
                    }
                }

                static Rotate90(dst, src, srcx, srcy) {

                    this.Transpose(dst, src, srcx, srcy);

                    Flip.FlipUD(dst, srcy, srcx);
                }

                static Rotate180(dst, src, srcx, srcy) {

                    const Channels = 4;

                    Common.Copy(dst, src, srcx * srcy * Channels);

                    Flip.FlipUD(dst, srcx, srcy);

                    Flip.FlipLR(dst, srcx, srcy);
                }

                static Rotate270(dst, src, srcx, srcy) {

                    Flip.FlipUD(src, srcx, srcy);

                    this.Transpose(dst, src, srcx, srcy);
                }
            }

            class Kreed {

                static Conc2D(c00, c01, c10, c11) {

                    var result = 0;

                    var acAreAlike = Common.IsLike(c00, c10);

                    var x = acAreAlike ? 1 : 0;
                    var y = (Common.IsLike(c01, c10) && !(acAreAlike)) ? 1 : 0;

                    var adAreAlike = Common.IsLike(c00, c11);

                    x += adAreAlike ? 1 : 0;
                    y += (Common.IsLike(c01, c11) && !(adAreAlike)) ? 1 : 0;

                    if (x <= 1)
                        result++;

                    if (y <= 1)
                        result--;

                    return (result);
                }
            }

            class ReverseAA {

                static Clamp(v, min, max) {

                    return parseInt(Math.min(max, Math.max(v, min)));
                }

                static FullClamp(value) {

                    return Common._Clip8(value);
                }

                static _ReverseAntiAlias(b1, b, d, e, f, h, h5, d0, f4) {

                    var n1 = b1;
                    var n2 = b;
                    var s = e;
                    var n3 = h;
                    var n4 = h5;
                    var aa = n2 - n1;
                    var bb = s - n2;
                    var cc = n3 - s;
                    var dd = n4 - n3;

                    var tilt = (7 * (bb + cc) - 3 * (aa + dd)) / 16;

                    var m = (s < 128) ? 2 * s : 2 * (255 - s);

                    m = Math.min(m, 2 * Math.abs(bb));
                    m = Math.min(m, 2 * Math.abs(cc));

                    tilt = this.Clamp(tilt, -m, m);

                    var s1 = s + tilt / 2;
                    var s0 = s1 - tilt;

                    n1 = d0;
                    n2 = d;
                    s = s0;
                    n3 = f;
                    n4 = f4;
                    aa = n2 - n1;
                    bb = s - n2;
                    cc = n3 - s;
                    dd = n4 - n3;

                    tilt = (7 * (bb + cc) - 3 * (aa + dd)) / 16;

                    m = (s < 128) ? 2 * s : 2 * (255 - s);

                    m = Math.min(m, 2 * Math.abs(bb));
                    m = Math.min(m, 2 * Math.abs(cc));

                    tilt = this.Clamp(tilt, -m, m);

                    var e1 = s + tilt / 2;
                    var e0 = e1 - tilt;

                    s = s1;
                    bb = s - n2;
                    cc = n3 - s;

                    tilt = (7 * (bb + cc) - 3 * (aa + dd)) / 16;

                    m = (s < 128) ? 2 * s : 2 * (255 - s);

                    m = Math.min(m, 2 * Math.abs(bb));
                    m = Math.min(m, 2 * Math.abs(cc));

                    tilt = this.Clamp(tilt, -m, m);

                    var e3 = s + tilt / 2;
                    var e2 = e3 - tilt;

                    return { rd: this.FullClamp(e0), gn: this.FullClamp(e1), bl: this.FullClamp(e2), alpha: this.FullClamp(e3) };
                }
            }

// image initialization
            class Init {

                static Buffer(Length, c) {

                    const Channels = 4;

                    var buffer = new Uint8ClampedArray(Length * Channels);

                    for (var i = 0; i < Length; i++) {

                        var index = i * Channels;

                        buffer[index] = parseInt(c);
                        buffer[index + 1] = parseInt(c);
                        buffer[index + 2] = parseInt(c);
                        buffer[index + 3] = 255;
                    }

                    return buffer;
                }

                static New(x, y) {

                    return this.Buffer(x * y, 0);
                }

                static Init(srcx, srcy, FilterScaleX, FilterScaleY, ComparisonThreshold) {

                    Common.ScaleX = FilterScaleX;
                    Common.ScaleY = FilterScaleY;
                    Common.SizeX = srcx * FilterScaleX;
                    Common.SizeY = srcy * FilterScaleY;
                    Common.Threshold = ComparisonThreshold;

                    Common.ScaledImage = this.New(Common.SizeX, Common.SizeY);
                }
            }

            // CRT
            // https://github.com/LIJI32/SameBoy/blob/master/Shaders/CRT.fsh
            var Filter = class {

                Apply(Input, srcx, srcy, scale, threshold) {

                    var Channels = 4;

                    scale = Math.max(1, scale);

                    Init.Init(srcx, srcy, scale, scale, threshold);

                    var total = Common.SizeY;
                    var current = 0;

                    for (var y = 0; y < Common.SizeY; y ++) {

                        var offset = y * Common.SizeX;
                        var positiony = y / Common.SizeY;

                        for (var x = 0; x < Common.SizeX; x ++) {

                            var argb = this.scale(Input, x / Common.SizeX, positiony, srcx, srcy);

                            Common.ScaledImage[(offset + x) * Channels] = Common.Red(argb);
                            Common.ScaledImage[(offset + x) * Channels + 1] = Common.Green(argb);
                            Common.ScaledImage[(offset + x) * Channels + 2] = Common.Blue(argb);
                            Common.ScaledImage[(offset + x) * Channels + 3] = Common.Alpha(argb);
                        }

                        current ++;
                    }

                    return new ImageData(Uint8ClampedArray.from(Common.ScaledImage), Common.SizeX,  Common.SizeY);
                }

                fract(x) {

                    return x - Math.floor(x);
                }

                mix(a, b, c) {

                    return Interpolate.Interpolate2P1Q(a, b, c);
                }

                Mul(x, y) {

                    var r = Common.Red(x) * y;
                    var g = Common.Green(x) * y;
                    var b = Common.Blue(x) * y;
                    var a = Common.Alpha(x) * y;

                    return Common.ARGBINT(a, r, g, b);
                }

                scale(image, ppx, ppy, srcx, srcy) {

                    const COLOR_LOW = 0.7;
                    const COLOR_HIGH = 1.0;
                    const VERTICAL_BORDER_DEPTH = 0.6;
                    const SCANLINE_DEPTH = 0.3;
                    const CURVENESS = 0.3;

                    var y_curve = Math.cos(ppx - 0.5) * CURVENESS + (1 - CURVENESS);
                    var y_multiplier = 8.0 / 7.0 / y_curve;

                    ppy *= y_multiplier;
                    ppy -= (y_multiplier - 1) / 2;

                    if (ppy < 0.0) return Common.ARGBINT(0, 0, 0, 0);
                    if (ppy > 1.0) return Common.ARGBINT(0, 0, 0, 0);

                    var x_curve = Math.cos(ppy - 0.5) * CURVENESS + (1 - CURVENESS);
                    var x_multiplier = 1 / x_curve;

                    ppx *= x_multiplier;
                    ppx -= (x_multiplier - 1) / 2;

                    if (ppx < 0.0) return Common.ARGBINT(0, 0, 0, 0);
                    if (ppx > 1.0) return Common.ARGBINT(0, 0, 0, 0);

                    var posx = this.fract(ppx * srcx);
                    var posy = this.fract(ppy * srcy);
                    var sub_posx = this.fract(ppx * srcx * 6);
                    var sub_posy = this.fract(ppy * srcy * 6);

                    var positionx = parseInt(ppx * srcx);
                    var positiony = parseInt(ppy * srcy);

                    var center = Common.CLR(image, srcx, srcy, positionx, positiony, 0, 0);
                    var left = Common.CLR(image, srcx, srcy, positionx, positiony, - 1, 0);
                    var right = Common.CLR(image, srcx, srcy, positionx, positiony, 1, 0);

                    if (posy < 1.0 / 6.0) {

                        center = this.mix(center, Common.CLR(image, srcx, srcy, positionx, positiony, 0, - 1), 0.5 - sub_posy / 2.0);
                        left = this.mix(left, Common.CLR(image, srcx, srcy, positionx, positiony, - 1, - 1), 0.5 - sub_posy / 2.0);
                        right = this.mix(right, Common.CLR(image, srcx, srcy, positionx, positiony, 1, - 1), 0.5 - sub_posy / 2.0);

                    } else if (posy > 5.0 / 6.0) {

                        center = this.mix(center, Common.CLR(image, srcx, srcy, positionx, positiony, 0, 1), sub_posy / 2.0);
                        left = this.mix(left, Common.CLR(image, srcx, srcy, positionx, positiony, - 1, 1), sub_posy / 2.0);
                        right = this.mix(right, Common.CLR(image, srcx, srcy, positionx, positiony, 1, 1), sub_posy / 2.0);
                    }

                    var scanline_multiplier;

                    if (posy < 0.5) {

                        scanline_multiplier = (posy * 2) * SCANLINE_DEPTH + (1 - SCANLINE_DEPTH);

                    } else {

                        scanline_multiplier = ((1 - posy) * 2) * SCANLINE_DEPTH + (1 - SCANLINE_DEPTH);
                    }

                    this.Mul(center, scanline_multiplier);
                    this.Mul(left, scanline_multiplier);
                    this.Mul(right, scanline_multiplier);

                    var odd = (ppx * srcx) & 1;

                    var gradient_position;

                    if (odd) {

                        posy += 0.5;
                        posy = this.fract(posy);
                    }

                    if (posy < 1.0 / 3.0) {

                        gradient_position = posy * 3.0;

                        this.Mul(center, gradient_position * VERTICAL_BORDER_DEPTH + (1 - VERTICAL_BORDER_DEPTH));
                        this.Mul(left, gradient_position * VERTICAL_BORDER_DEPTH + (1 - VERTICAL_BORDER_DEPTH));
                        this.Mul(right, gradient_position * VERTICAL_BORDER_DEPTH + (1 - VERTICAL_BORDER_DEPTH));

                    } else if (posy > 2.0 / 3.0) {

                        gradient_position = (1 - posy) * 3.0;

                        this.Mul(center, gradient_position * VERTICAL_BORDER_DEPTH + (1 - VERTICAL_BORDER_DEPTH));
                        this.Mul(left, gradient_position * VERTICAL_BORDER_DEPTH + (1 - VERTICAL_BORDER_DEPTH));
                        this.Mul(right, gradient_position * VERTICAL_BORDER_DEPTH + (1 - VERTICAL_BORDER_DEPTH));
                    }

                    if (posx < 1.0 / 6.0 || posx > 5.0 / 6.0) {

                        posy += 0.5;
                        posy = this.fract(posy);

                        if (posy < 1.0 / 3.0) {

                            gradient_position = posy * 3.0;

                            if (posx < 0.5) {

                                gradient_position = 1 - (1 - gradient_position) * (1 - (posx) * 6.0);

                            } else {

                                gradient_position = 1 - (1 - gradient_position) * (1 - (1 - posx) * 6.0);
                            }

                            this.Mul(center, gradient_position * VERTICAL_BORDER_DEPTH + (1 - VERTICAL_BORDER_DEPTH));
                            this.Mul(left, gradient_position * VERTICAL_BORDER_DEPTH + (1 - VERTICAL_BORDER_DEPTH));
                            this.Mul(right, gradient_position * VERTICAL_BORDER_DEPTH + (1 - VERTICAL_BORDER_DEPTH));

                        } else if (posy > 2.0 / 3.0) {

                            gradient_position = (1 - posy) * 3.0;

                            if (posx < 0.5) {

                                gradient_position = 1 - (1 - gradient_position) * (1 - (posx) * 6.0);

                            } else {

                                gradient_position = 1 - (1 - gradient_position) * (1 - (1 - posx) * 6.0);
                            }

                            this.Mul(center, gradient_position * VERTICAL_BORDER_DEPTH + (1 - VERTICAL_BORDER_DEPTH));
                            this.Mul(left, gradient_position * VERTICAL_BORDER_DEPTH + (1 - VERTICAL_BORDER_DEPTH));
                            this.Mul(right, gradient_position * VERTICAL_BORDER_DEPTH + (1 - VERTICAL_BORDER_DEPTH));
                        }
                    }

                    var midleft = this.mix(left, center, 0.5);
                    var midright = this.mix(right, center, 0.5);

                    var ret;

                    var cr = Common.Red(center);
                    var cg = Common.Green(center);
                    var cb = Common.Blue(center);
                    var mlb = Common.Blue(midleft);
                    var mrr = Common.Red(midright);
                    var mrg = Common.Green(midright);
                    var lb = Common.Blue(left);
                    var rr = Common.Red(right);
                    var rg = Common.Green(right);
                    var alpha = Common.Alpha(center);

                    if (posx < 1.0 / 6.0) {

                        ret = this.mix(Common.ARGBINT(alpha, COLOR_HIGH * cr, COLOR_LOW * cg, COLOR_HIGH * lb), Common.ARGBINT(alpha, COLOR_HIGH * cr, COLOR_LOW * cg, COLOR_LOW * lb), sub_posx);

                    } else if (posx < 2.0 / 6.0) {

                        ret = this.mix(Common.ARGBINT(alpha, COLOR_HIGH * cr, COLOR_LOW * cg, COLOR_LOW * lb), Common.ARGBINT(alpha, COLOR_HIGH * cr, COLOR_HIGH * cg, COLOR_LOW * mlb), sub_posx);

                    } else if (posx < 3.0 / 6.0) {

                        ret = this.mix(Common.ARGBINT(alpha, COLOR_HIGH * cr, COLOR_HIGH * cg, COLOR_LOW * mlb), Common.ARGBINT(alpha, COLOR_LOW * mrr, COLOR_HIGH * cg, COLOR_LOW * cb), sub_posx);

                    } else if (posx < 4.0 / 6.0) {

                        ret = this.mix(Common.ARGBINT(alpha, COLOR_LOW * mrr, COLOR_HIGH * cg, COLOR_LOW * cb), Common.ARGBINT(alpha, COLOR_LOW * rr, COLOR_HIGH * cg, COLOR_HIGH * cb), sub_posx);

                    } else if (posx < 5.0 / 6.0) {

                        ret = this.mix(Common.ARGBINT(alpha, COLOR_LOW * rr, COLOR_HIGH * cg, COLOR_HIGH * cb), Common.ARGBINT(alpha, COLOR_LOW * rr, COLOR_LOW * mrg, COLOR_HIGH * cb), sub_posx);

                    } else {

                        ret = this.mix(Common.ARGBINT(alpha, COLOR_LOW * rr, COLOR_LOW * mrg, COLOR_HIGH * cb), Common.ARGBINT(alpha, COLOR_HIGH * rr, COLOR_LOW * rg, COLOR_HIGH * cb), sub_posx);
                    }

                    if (positionx < 1) {

                        this.Mul(ret, positionx);

                    } else if (positionx > srcx - 1) {

                        this.Mul(ret, srcx - positionx);
                    }

                    if (positiony < 1) {

                        this.Mul(ret, positiony);

                    } else if (positiony > srcy - 1) {

                        this.Mul(ret, srcy - positiony);
                    }

                    return ret;
                }
            }
            return Filter;
        }());

        resolve(new CRT().Apply(image_data.data, image_data.width, image_data.height, scale, 0));
    });
}


function crt(image_data, scale, pool) {

    return new Promise(function(resolve, reject){

        if(Boolean(pool)) {

            pool.exec(window.crt_process_function, [
                image_data,
                scale,
            ]).catch((e) => {

                return window.crt_process_function(image_data, scale);
            }).then((result) => {

                resolve(result);
            }).timeout(40 * 1000);

        }else {

            window.crt_process_function(image_data, scale).then((result) => {

                resolve(result);
            });
        }
    });
};

module.exports = { crt };